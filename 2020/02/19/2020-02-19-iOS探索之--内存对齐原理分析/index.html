<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言之前在探索 alloc流程 的时候有关内存对齐 方面的内容没有去详细分析, 接下来在本文中着重对内存对齐方面的内容进行补充和继续探索。 内存对齐的概念 首先我们要搞清楚什么是内存对齐 ?  内存对齐 (Memory alignment) , 也叫做字节对齐。计算机中的内存空间都是按照 byte 划分的, 从理论上讲对任何类型的变量的访问可以从任何地址开始, 但是实际情况下在访问特定类型变量的时">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS探索之--内存对齐原理分析">
<meta property="og:url" content="http://example.com/2020/02/19/2020-02-19-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言之前在探索 alloc流程 的时候有关内存对齐 方面的内容没有去详细分析, 接下来在本文中着重对内存对齐方面的内容进行补充和继续探索。 内存对齐的概念 首先我们要搞清楚什么是内存对齐 ?  内存对齐 (Memory alignment) , 也叫做字节对齐。计算机中的内存空间都是按照 byte 划分的, 从理论上讲对任何类型的变量的访问可以从任何地址开始, 但是实际情况下在访问特定类型变量的时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/rinna/OneDrive/MarkDown/image/1705940cf0591a02tplv-t2oaga2asx-image.image">
<meta property="og:image" content="c:/Users/rinna/OneDrive/MarkDown/image/1705941a4cc3c65atplv-t2oaga2asx-image.image">
<meta property="article:published_time" content="2020-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-01T03:03:38.766Z">
<meta property="article:author" content="Ccc">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/rinna/OneDrive/MarkDown/image/1705940cf0591a02tplv-t2oaga2asx-image.image">

<link rel="canonical" href="http://example.com/2020/02/19/2020-02-19-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>iOS探索之--内存对齐原理分析 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/19/2020-02-19-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS探索之--内存对齐原理分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-19T00:00:00+08:00">2020-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-01 11:03:38" itemprop="dateModified" datetime="2022-06-01T11:03:38+08:00">2022-06-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">iOS底层学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在探索 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844904095141085192#heading-7">alloc流程</a> 的时候有关<code>内存对齐</code> 方面的内容没有去详细分析, 接下来在本文中着重对内存对齐方面的内容进行补充和继续探索。</p>
<h2 id="内存对齐的概念"><a href="#内存对齐的概念" class="headerlink" title="内存对齐的概念"></a>内存对齐的概念</h2><blockquote>
<p>首先我们要搞清楚什么是内存对齐 ?</p>
</blockquote>
<p><code>内存对齐 (Memory alignment)</code> , 也叫做字节对齐。计算机中的内存空间都是按照 byte 划分的, 从理论上讲对任何类型的变量的访问可以从任何地址开始, 但是实际情况下在访问特定类型变量的时候经常在特定的内存地址访问, 这就需要各类型数据按照一定的规则在空间上排列, 而不是按顺序的一个一个排放, 这就是内存对齐。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%B9%E9%BD%90">参考自百度百科</a></p>
<blockquote>
<p>为什么要进行内存对齐 ?</p>
</blockquote>
<p>为了减少CPU访问内存的次数, 提高计算机性能, 一些计算机硬件平台要求存储在内存中的变量需要按照自然边界对齐。</p>
<ol>
<li>性能提升</li>
</ol>
<p>从内存占用的角度讲, 对齐以后比未对齐时有些情况反而增加了内存分配的开支, 是为了什么?</p>
<p>数据结构 (尤其是栈) 应该尽可能地在自然边界上对齐, 为了访问未对齐的内存, 处理器就需要做两次内存访问, 而对齐的内存访问只需要一次访问。重要的是提高内存系统的性能。（<strong>以空间换取时间</strong>）</p>
<ol start="2">
<li>跨平台</li>
</ol>
<p>有些硬件平台并不能访问任意地址上的任意数据的，只能处理特定类型的数据，否则会导致硬件层级的错误。</p>
<p>有些CPU（如基于 Alpha，IA-64，MIPS，和 SuperH 体系的）拒绝读取未对齐数据。当一个程序要求这些 CPU 读取未对齐数据时，这时 CPU 会进入异常处理状态并且通知程序不能继续执行。</p>
<p>举个例子，在 ARM，MIPS，和 SH 硬件平台上，当操作系统被要求存取一个未对齐数据时会默认给应用程序抛出硬件异常。所以，如果编译器不进行内存对齐，那在很多平台的上的开发将难以进行。</p>
<h2 id="获取对象内存大小的方法"><a href="#获取对象内存大小的方法" class="headerlink" title="获取对象内存大小的方法"></a>获取对象内存大小的方法</h2><p>在开始研究内存对齐之前, 首先我们需要了解一下下面这三个方法的具体作用:</p>
<ul>
<li><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3></li>
</ul>
<p>他是一个操作符, 不是函数, 作用对象是数据类型, 主要作用于编译时。因此, 它作用于变量时, 同样是对其类型进行操作, 得到的结果是该数据类型占用空间的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct test</span><br><span class="line">&#123;</span><br><span class="line">  int a;     //4</span><br><span class="line">  double b;  //8</span><br><span class="line">&#125; MyTest;</span><br><span class="line">NSLog(@&quot;%zd&quot;, sizeof(MyTest));</span><br><span class="line">//</span><br><span class="line">// 上面的结果得到 16 个字节, 需要考虑内存对齐问题, 关于内存对齐规则后面提到</span><br></pre></td></tr></table></figure>

<p>sizeof 只会计算类型所占用的内存大小, 不会关心具体的内存布局。(例如, 64位结构下, 我们自定义一个 NSObject 对象, 里面无论有多少个成员变量, 最后的结果都是 8 个字节)</p>
<ul>
<li><h3 id="class-getInstanceSize"><a href="#class-getInstanceSize" class="headerlink" title="class_getInstanceSize"></a>class_getInstanceSize</h3></li>
</ul>
<p>这是 <code>runtime</code> 提供的一个API, 用于获取类的实例对象所占用的内存大小, 返回具体的字节数。</p>
<p>我们通过在之前获取到的 objc4 源码中搜索该方法, 在 objc-class.mm 中找到了该方法的实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return 0;</span><br><span class="line">    return cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br><span class="line">// Class&#x27;s ivar size rounded up to a pointer-size boundary.</span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">  return word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span><br><span class="line"></span><br><span class="line">  // 7    0000 0111</span><br><span class="line">  // ~7   1111 1000</span><br><span class="line">  // 假设 x 为 4，那么就是</span><br><span class="line">  // </span><br><span class="line">  // 0000 0100  + 7</span><br><span class="line">  // 0000 1011  11</span><br><span class="line">  // &amp;</span><br><span class="line">  // 1111 1000</span><br><span class="line">  // </span><br><span class="line">  // 0000 1000  8</span><br><span class="line"></span><br><span class="line">  return (x + WORD_MASK) &amp; ~WORD_MASK; // WORD_MASK 为 7</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">#define WORD_MASK 7UL</span><br></pre></td></tr></table></figure>
<p>此方法在获取对象所占的内存大小时，会去调用一个 <code>word_align</code> 方法，在该方法中通过将传进来的数值进行 <code> (x + 7) &amp; ~7</code> 的操作将数值中非8的部分（也就是 &lt;8 的部分对齐到了8）进行了 8 字节对齐操作，所以此方法获取的大小是对象成员变量经过8字节对齐后所占的总大小。</p>
<ul>
<li><h3 id="malloc-size"><a href="#malloc-size" class="headerlink" title="malloc_size"></a>malloc_size</h3></li>
</ul>
<p>这个函数获取的是系统实际分配的内存大小, 也就是经过对象内存对齐后的大小（对象 16字节对齐后的大小），所以 <code>malloc_size 与 class_getInstanceSize 的结果是不一样的</code>,  具体的实现可以在libmalloc源码中找到。代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">size_t malloc_size(const void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	size_t size = 0;</span><br><span class="line">	if (!ptr) &#123;</span><br><span class="line">		return size;</span><br><span class="line">	&#125;</span><br><span class="line">	(void)find_registered_zone(ptr, &amp;size);</span><br><span class="line">	return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">static inline malloc_zone_t *</span><br><span class="line">find_registered_zone(const void *ptr, size_t *returned_size)</span><br><span class="line">&#123;</span><br><span class="line">	// Returns a zone which contains ptr, else NULL</span><br><span class="line">	if (0 == malloc_num_zones) &#123;</span><br><span class="line">		if (returned_size) &#123;</span><br><span class="line">			*returned_size = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	// first look in the lite zone</span><br><span class="line">	if (lite_zone) &#123;</span><br><span class="line">		malloc_zone_t *zone = lite_zone;</span><br><span class="line">		size_t size = zone-&gt;size(zone, ptr);</span><br><span class="line">		if (size) &#123; // Claimed by this zone?</span><br><span class="line">			if (returned_size) &#123;</span><br><span class="line">				*returned_size = size;</span><br><span class="line">			&#125;</span><br><span class="line">			// Return the virtual default zone instead of the lite zone - see &lt;rdar://problem/24994311&gt;</span><br><span class="line">			return default_zone;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// The default zone is registered in malloc_zones[0]. There&#x27;s no danger that it will ever be unregistered.</span><br><span class="line">	// So don&#x27;t advance the FRZ counter yet.</span><br><span class="line">	malloc_zone_t *zone = malloc_zones[0];</span><br><span class="line">	size_t size = zone-&gt;size(zone, ptr);</span><br><span class="line">	if (size) &#123; // Claimed by this zone?</span><br><span class="line">		if (returned_size) &#123;</span><br><span class="line">			*returned_size = size;</span><br><span class="line">		&#125;</span><br><span class="line">		// Asan and others replace the zone at position 0 with their own zone.</span><br><span class="line">		// In that case just return that zone as they need this information.</span><br><span class="line">		// Otherwise return the virtual default zone, not the actual zone in position 0.</span><br><span class="line">		if (!has_default_zone0()) &#123;</span><br><span class="line">			return zone;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return default_zone;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int32_t volatile *pFRZCounter = pFRZCounterLive;   // Capture pointer to the counter of the moment</span><br><span class="line">	OSAtomicIncrement32Barrier(pFRZCounter); // Advance this counter -- our thread is in FRZ</span><br><span class="line">	unsigned index;</span><br><span class="line">	int32_t limit = *(int32_t volatile *)&amp;malloc_num_zones;</span><br><span class="line">	malloc_zone_t **zones = &amp;malloc_zones[1];</span><br><span class="line">	// From this point on, FRZ is accessing the malloc_zones[] array without locking</span><br><span class="line">	// in order to avoid contention on common operations (such as non-default-zone free()).</span><br><span class="line">	// In order to ensure that this is actually safe to do, register/unregister take care</span><br><span class="line">	// to:</span><br><span class="line">	//</span><br><span class="line">	//   1. Register ensures that newly inserted pointers in malloc_zones[] are visible</span><br><span class="line">	//      when malloc_num_zones is incremented. At the moment, we&#x27;re relying on that store</span><br><span class="line">	//      ordering to work without taking additional steps here to ensure load memory</span><br><span class="line">	//      ordering.</span><br><span class="line">	//</span><br><span class="line">	//   2. Unregister waits for all readers in FRZ to complete their iteration before it</span><br><span class="line">	//      returns from the unregister call (during which, even unregistered zone pointers</span><br><span class="line">	//      are still valid). It also ensures that all the pointers in the zones array are</span><br><span class="line">	//      valid until it returns, so that a stale value in limit is not dangerous.</span><br><span class="line">	for (index = 1; index &lt; limit; ++index, ++zones) &#123;</span><br><span class="line">		zone = *zones;</span><br><span class="line">		size = zone-&gt;size(zone, ptr);</span><br><span class="line">		if (size) &#123; // Claimed by this zone?</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// Unclaimed by any zone.</span><br><span class="line">	zone = NULL;</span><br><span class="line">	size = 0;</span><br><span class="line">out:</span><br><span class="line">	if (returned_size) &#123;</span><br><span class="line">		*returned_size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	OSAtomicDecrement32Barrier(pFRZCounter); // our thread is leaving FRZ</span><br><span class="line">	return zone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存对齐的原则"><a href="#内存对齐的原则" class="headerlink" title="内存对齐的原则"></a>内存对齐的原则</h2><ul>
<li><h3 id="数据成员对齐规则"><a href="#数据成员对齐规则" class="headerlink" title="数据成员对齐规则"></a>数据成员对齐规则</h3><p>结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从成员大小或者成员的子成员大小（<em>只要该成员有子成员，比如说是数组，结构体等</em>）的整数倍开始 (比如int在32位机为４字节,则要从４的整数倍地址开始存储。)  举例如下: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct &#123;</span><br><span class="line">    int a;			// 0-3  补位 4,5,6,7</span><br><span class="line">    double b;		// 8-15</span><br><span class="line">    char c;			// 16		部位 17,18,19</span><br><span class="line">    short d;		// 20-24</span><br><span class="line">&#125; struct1;</span><br><span class="line">//</span><br><span class="line">NSLog(@&quot;%lu&quot;,sizeof(struct1));</span><br><span class="line">// 打印结果</span><br><span class="line">2020-02-18 20:41:12.974406+0800 LGTest[36584:2131553] 24</span><br></pre></td></tr></table></figure>

<p><em>注意: 测试环境均为 64位 环境, 32位环境下感兴趣的同学可以自行测试。</em></p>
<p>分析上面的结果, 首先 <code>a</code> 为 int 类型占4位, 所以 <code>a</code> 所在的区域为0-3位。接下来的 <code>b</code> 为 double 类型占8位, 因为内存对齐原则起始位置应该为8的整数倍, 所以起始位置应该为8, 前面的4位补齐。然后 <code>c</code> 的起始位置就是16, 因为 <code>c</code> 只需要1位, 那么 <code>d</code> 的起始位置就是17, 17如果需要是 4 的倍数需要变成 20, 所以前面补齐3位, <code>d</code> 的起始位置为20, 20加上 <code>d</code> 的4位就得出最终的结果24。</p>
<p>还可以用下面的方式去理解:</p>
<blockquote>
<p>我们把内存对齐原则理解为 <code>min(m, n)</code> 的公式, 其中 m表示当前成员的开始位置, n表示当前成员所需要的位数。如果满足条件 m 整除 n 的话, 就让 n 从 m 位置开始存储, 否则继续检查 m+1 能否整除 n, 直到可以整除, 从而就确定了当前成员的开始位置。</p>
<p>上面结构体中的 <code>b</code> 就可以看做, <code>min(4, 8)</code> , 直到 <code>min(8, 8)</code> 时满足条件, 所以 <code>b</code> 的存储区域为 <code>8-15</code> 这8位</p>
<p>然后 <code>c</code> 就是 <code>min(16, 1)</code> , 可以直接整除, <code>c</code> 的区域就是 16, 占1位</p>
<p>最后 <code>d</code> 为 <code>min(17, 4)</code> , 直到 <code>min(20, 4)</code> 时满足条件, 可以得出, <code>d</code> 所在的区域为 20-23 </p>
</blockquote>
</li>
<li><h3 id="结构体作为成员对齐规则"><a href="#结构体作为成员对齐规则" class="headerlink" title="结构体作为成员对齐规则"></a>结构体作为成员对齐规则</h3><p>如果一个结构里有某些结构体成员, 则结构体成员要从其内部最大元素大小的整数倍地址开始存储。(struct a 里存有 struct b, b 里有 char, int , double等元素, 那 b 应该从8的整数倍开始存储。) 可以看一下下面的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct4</span><br><span class="line">&#123;</span><br><span class="line">  double a;</span><br><span class="line">  short b;</span><br><span class="line">    struct MyStruct5 &#123;</span><br><span class="line">        int c;</span><br><span class="line">        double d;</span><br><span class="line">    &#125; struct5;</span><br><span class="line">&#125; struct4;</span><br><span class="line">//</span><br><span class="line">NSLog(@&quot;%lu&quot;, sizeof(struct4));</span><br><span class="line">// 打印结果</span><br><span class="line">2020-02-18 21:45:20.741445+0800 LGTest[38755:2172577] 32</span><br><span class="line">  </span><br><span class="line">// 按照原则1                           // 遵循原则2</span><br><span class="line">// 0-7                                //  0-7</span><br><span class="line">// 8-11                               //  8-11</span><br><span class="line">// 12-15  min(12, 4)                  //  16-19  min(12, 8)</span><br><span class="line">// 16-23  min(16, 8)                  //  24-31  min(20, 8)</span><br></pre></td></tr></table></figure>

<p>可以看到, 如果我们继续按照上面的方式去存储的话, 得到的结果应该是 24。根据结构体作为成员的规则要求, <code>struct5</code> 的最大元素大小为 8 位, 所以 <code>struct5</code> 的第一个数据成员的起始位置应该是 8 的整数倍, 也就是 <code>min(12, 8)</code> , 然后再继续往下存储, 最后得出结果为32。</p>
</li>
<li><h3 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h3><p>结构体的总大小, 也就是 <code>sizeof</code> 的结果, 必须是其内部最大成员的整数倍, 不足的话需要补齐。实例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct2</span><br><span class="line">&#123;</span><br><span class="line">  int a;</span><br><span class="line">  char b;</span><br><span class="line">&#125; struct2;</span><br><span class="line">struct MyStruct3</span><br><span class="line">&#123;</span><br><span class="line">  double a;</span><br><span class="line">  char b;</span><br><span class="line">&#125; struct3;</span><br><span class="line">//</span><br><span class="line">NSLog(@&quot;%lu&quot;, sizeof(struct2));</span><br><span class="line">NSLog(@&quot;%lu&quot;, sizeof(struct3));</span><br><span class="line">// 打印结果</span><br><span class="line">2020-02-18 21:25:22.008413+0800 LGTest[38015:2158667] 8</span><br><span class="line">2020-02-18 21:25:22.008605+0800 LGTest[38015:2158667] 16</span><br></pre></td></tr></table></figure>

<p>假如仅凭第一条的规则, 我们可以得出, <code>struct2</code> 的打印结果应该为 5, <code>struct3</code> 的结果应该为 9。但是我们的打印结果是 8 和 16, 这就验证了我们这一条的原则, <code>struct2</code> 的结果必须是 4 的倍数, 所以结果是 8; <code>struct3</code> 的结果应该是 8 的倍数, 所以结果是 16。</p>
</li>
</ul>
<h2 id="对象的内存对齐"><a href="#对象的内存对齐" class="headerlink" title="对象的内存对齐"></a>对象的内存对齐</h2><h3 id="1-属性的内存对齐"><a href="#1-属性的内存对齐" class="headerlink" title="1. 属性的内存对齐"></a>1. 属性的内存对齐</h3><p>了解了内存对齐的原则, 下面我们再来看一下对象的内存对齐是在什么时候进行的。通过之前的 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844904095141085192#heading-7">alloc流程探索</a> 过程中我们知道了对象的创建是在 <code>callAlloc</code> 方法中完成的, </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class="line">&#123;</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line"></span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        // No alloc/allocWithZone implementation. Go straight to the allocator.</span><br><span class="line">        // fixme store hasCustomAWZ in the non-meta class and </span><br><span class="line">        // add it to canAllocFast&#x27;s summary</span><br><span class="line">        if (fastpath(cls-&gt;canAllocFast())) &#123;</span><br><span class="line">            // No ctors, raw isa, etc. Go straight to the metal.</span><br><span class="line">            bool dtor = cls-&gt;hasCxxDtor();</span><br><span class="line">            id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize());</span><br><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span><br><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Has ctor or raw isa or something. Use the slower path.</span><br><span class="line">            id obj = class_createInstance(cls, 0);</span><br><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    // No shortcuts available.</span><br><span class="line">    if (allocWithZone) return [cls allocWithZone:nil];</span><br><span class="line">    return [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据方法名我们就不难发现 <code>id obj = class_createInstance(cls, 0);</code> 这一行代码应该就是创建对象的方法, 下面我们在往里逐一探索:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">id class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">static __attribute__((always_inline)) </span><br><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span><br><span class="line">                              bool cxxConstruct = true, </span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    // Read class&#x27;s info bits all at once for performance</span><br><span class="line">    bool hasCxxCtor = cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast = cls-&gt;canAllocNonpointer();</span><br><span class="line"></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);	// </span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        obj = (id)calloc(1, size);</span><br><span class="line">        if (!obj) return nil;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (zone) &#123;</span><br><span class="line">            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj = (id)calloc(1, size);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">        // Use raw pointer isa on the assumption that they might be </span><br><span class="line">        // doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到这里, 发现这一行代码 <code>size_t size = cls-&gt;instanceSize(extraBytes);</code> , 继续往下走:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">  size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">  // CF requires all objects be at least 16 bytes.</span><br><span class="line">  if (size &lt; 16) size = 16;</span><br><span class="line">  return size;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// Class&#x27;s ivar size rounded up to a pointer-size boundary.</span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">  return word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span><br><span class="line">  return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">#define WORD_MASK 7UL</span><br></pre></td></tr></table></figure>

<p>这里当我们看到 <code>alignedInstanceSize()</code> 方法时发现此方法就是上面提到过的 <code>class_getInstanceSize</code> 方法的内部实现, 此方法的作用就是用来获取实例对象所占用的内存的大小, 此时就明了了。下面我们来着重看一下这个方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span><br><span class="line">  return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">#define WORD_MASK 7UL</span><br><span class="line"></span><br><span class="line">// 假设 x 为 9, 转换为二进制为  </span><br><span class="line">// x + WORD_MASK (7) = 16 转换为二进制</span><br><span class="line">//</span><br><span class="line">// 0001 0000   (即 16)</span><br><span class="line">// &amp;</span><br><span class="line">// 1111 1000   (&amp; 上 -7的二进制)</span><br><span class="line">// 0001 0000	 (16)</span><br><span class="line">//</span><br><span class="line">// 实际为 (x + 7) &gt;&gt; 3 &lt;&lt; 3</span><br></pre></td></tr></table></figure>

<p>根据方法名字可以看出, 该方法主要做的工作就是 <code>字节对齐</code> , 这正是我们要找的东西。通过上面对算法的模拟, 我们可以看出, 在这里系统对实例对象所占用的内存 (<strong>也就是对象属性所需要占用的内存大小</strong>) 进行了 <code>8字节对齐</code> 。然后回过头来通过 <code>instanceSize(size_t extraBytes)</code> 该方法的实现得知, 对象的内存大小至少为 16 字节。</p>
<h3 id="2-对象的内存对齐"><a href="#2-对象的内存对齐" class="headerlink" title="2. 对象的内存对齐"></a>2. 对象的内存对齐</h3><p>通过上面的探索我们知道了对象属性的 <code>8字节对齐</code> , 并且对象在申请内存空间时至少为16字节。下面来继续验证一下我们的结论是否正确:</p>
<p><em>这里需要注意: 在计算对象内存大小时不要忽略 isa 的 8 字节大小。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 自定义类</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@property (nonatomic, assign) long height;</span><br><span class="line">@property (nonatomic, strong) NSString *hobby;</span><br><span class="line">// </span><br><span class="line">MCPerson *person = [[MCPerson alloc] init];</span><br><span class="line">NSLog(@&quot;%lu&quot;, class_getInstanceSize([MCPerson class]));</span><br><span class="line">NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)(person)));</span><br><span class="line">// 打印结果</span><br><span class="line">2020-02-18 23:39:29.977673+0800 LGTest[42667:2246768] 40</span><br><span class="line">2020-02-18 23:39:29.979105+0800 LGTest[42667:2246768] 48</span><br></pre></td></tr></table></figure>

<p>通过打印结果可以看出, 对象需要的内存空间为 40, 但是实际开辟的内存空间确实 48。那么到底是在哪里发成了问题:</p>
<p><img src="C:/Users/rinna/OneDrive/MarkDown/image/1705940cf0591a02tplv-t2oaga2asx-image.image"></p>
<p>从上图发现, 调用 <code>calloc</code> 方法时我们申请的内存大小是 40, 这里是没有问题的。继续往下执行, </p>
<p><img src="C:/Users/rinna/OneDrive/MarkDown/image/1705941a4cc3c65atplv-t2oaga2asx-image.image"></p>
<p>然后我们打印一下生成的对象的内存大小发现, 结果为 <code>0x0000000000000030</code> , 转换成10进制为 <code>48</code> 。那么, 问题出在 <code>calloc</code> 方法, 关于 <code>calloc</code> 的分析由于篇幅较长这里不做叙述了, 有兴趣的同学可以去看看 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844904033908424717">Cooci老师的malloc分析</a>, 下面我们直接进入重点实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static MALLOC_INLINE size_t</span><br><span class="line">segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)</span><br><span class="line">&#123;</span><br><span class="line">	// size = 40</span><br><span class="line">	size_t k, slot_bytes;</span><br><span class="line"></span><br><span class="line">	if (0 == size) &#123;</span><br><span class="line">		size = NANO_REGIME_QUANTA_SIZE; // Historical behavior</span><br><span class="line">	&#125;</span><br><span class="line">	// 40 + 16-1 &gt;&gt; 4 &lt;&lt; 4</span><br><span class="line">	// 40 - 16*3 = 48</span><br><span class="line"></span><br><span class="line">	//</span><br><span class="line">	// 16</span><br><span class="line">  // #define NANO_REGIME_QUANTA_SIZE	(1 &lt;&lt; SHIFT_NANO_QUANTUM)	// 16</span><br><span class="line">	k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta</span><br><span class="line">	slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;							// multiply by power of two quanta size</span><br><span class="line">	*pKey = k - 1;													// Zero-based!</span><br><span class="line"></span><br><span class="line">	return slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对 <code>calloc</code> 的一连串探索操作, 最终我们找到了上面的方法, 也找到了对象申请内存大小与实际大小不一样的关键问题。可以看出我们传过来的 <code>size</code> 经过 <code>(size + 16 - 1) &gt;&gt; 16 &lt;&lt; 16</code> 之后返回, 这不类似于之前属性的 <code>8字节对齐</code> 吗, 不同点在于这里是 <code>16字节对齐</code> 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这次内存对齐原理的全部内容, 通过以上的内容, 我们可以明白内存对齐的相关概念, 以及对象创建的过程中是怎样进行内存对齐的。首先在获取对象所需要的内存大小的时候进行了 属性的 <code>8字节对齐</code>, 然后在返回时进行了 <code>&lt;16</code> 判断, 最后就是 <code>calloc</code> 申请内存时又进行了一次对象的 <code>16字节对齐</code> 。<strong>通过这两次的字节对齐, 能有防止访问溢出, 同时也能够有效的提高寻址访问效率。</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/16/2020-02-16-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--KVC%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" rel="prev" title="iOS探索之--KVC 原理分析">
      <i class="fa fa-chevron-left"></i> iOS探索之--KVC 原理分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/12/2020-03-12-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--isa%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%8C%87%E5%90%91%E5%88%86%E6%9E%90/" rel="next" title="iOS探索之--isa 的初始化和指向分析">
      iOS探索之--isa 的初始化和指向分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">内存对齐的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">获取对象内存大小的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sizeof"><span class="nav-number">3.1.</span> <span class="nav-text">sizeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-getInstanceSize"><span class="nav-number">3.2.</span> <span class="nav-text">class_getInstanceSize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-size"><span class="nav-number">3.3.</span> <span class="nav-text">malloc_size</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">4.</span> <span class="nav-text">内存对齐的原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="nav-number">4.1.</span> <span class="nav-text">数据成员对齐规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="nav-number">4.2.</span> <span class="nav-text">结构体作为成员对齐规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B6%E5%B0%BE%E5%B7%A5%E4%BD%9C"><span class="nav-number">4.3.</span> <span class="nav-text">收尾工作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">5.</span> <span class="nav-text">对象的内存对齐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">5.1.</span> <span class="nav-text">1. 属性的内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">5.2.</span> <span class="nav-text">2. 对象的内存对齐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ccc"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Ccc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ccc</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
